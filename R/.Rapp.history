check_structure(seed, "vector", "numeric", 1, null_ok = TRUE)
cat(paste0("== Seed set to ", seed, " ==\n\n"))
set.seed(seed)
stopifnot(is.list(time_obs))
stopifnot(is.list(Y))
stopifnot(isTRUE(all.equal(length(time_obs), length(Y))))
check_structure(K, "vector", "numeric", 1)
check_structure(K, "vector", "numeric", K)
check_structure(K, "vector", "numeric", p)
check_natural(K)
check_structure(L, "vector", "numeric", 1)
check_natural(L)
list_hyper <- set_hyper()
list_hyper
sigma_zeta <- list_hyper$sigma_zeta#
  mu_beta <- list_hyper$mu_beta#
  Sigma_beta <- list_hyper$Sigma_beta#
  A <- list_hyper$A
check_structure(n_g, "vector", "numeric", 1, null_ok = TRUE)
!is.null(n_g)
if (!is.null(n_g)) check_natural(n_g)
check_natural(n_g)
check_structure(time_g, "vector", "numeric", null_ok = TRUE)
check_structure(n_mfvb, "vector", "numeric", 1)
n_mfvb
check_natural(n_mfvb)
!is.null(Psi_g)
stopifnot(is.list(Psi_g))
check_structure(verbose, "vector", "logical", 1)
verbose
verbose <- TRUE
check_structure(verbose, "vector", "logical", 1)
stopifnot(is.list(time_obs[[1]])) # function not implemented for format format_univ = TRUE
K
L
d <- (K+2)*(L+1)
d
N <- length(time_obs) # move to vmp_gauss_fpca and vmp_gauss_mfpca
p <- length(time_obs[[1]])
N
p
get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
t_min
t_min <- 1.01*min(time_vec) - 0.01*max(time_vec)
t_min
t_max
t_max <- 1.01*max(time_vec) - 0.01*min(time_vec)
t_max
int_knots <- lapply(#
      K, function(x) quantile(unique(time_vec), seq(0, 1, length = x)[-c(1, x)])#
    )
N <- length(time_obs)
p
p <- length(time_obs[[1]])
p
int_knots
p <- length(time_obs[[1]])#
    for(i in 1:N) {#
      C[[i]] <- vector("list", length = p)#
      for(j in 1:p) {#
        X <- X_design(time_obs[[i]][[j]])#
        Z <- ZOSull(time_obs[[i]][[j]], range.x = c(0, 1), intKnots = int_knots[[j]])#
        C[[i]][[j]] <- cbind(X, Z)#
      }#
    }
stopifnot(!is.null(n_g))
stopifnot(is.null(n_g))
is.null(time_g)
is.null(n_g)
is.null(time_g)
stopifnot(is.null(n_g))
stopifnot(!is.null(n_g))
n_g <- length(time_g)
X_g <- X_design(time_g)
Z_g <- ZOSull(time_g, range.x=c(t_min, t_max), intKnots=int_knots)
X_g <- X_design(time_g)#
  Z_g <- lapply(#
    int_knots,#
    function(x) ZOSull(time_g, range.x = c(0, 1), intKnots = x)#
  )#
  C_g <- lapply(Z_g, function(Z) cbind(X_g, Z))
source("utils.R")
grid_obj <- get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
n_g
is.null(time_g)
stopifnot(is.null(n_g))
if(is.null(n_g)) n_g <- length(time_g)
source("utils.R")
grid_obj <- get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
C <- grid_obj$C#
  n_g <- grid_obj$n_g#
  time_g <- grid_obj$time_g#
  C_g <- grid_obj$C_g
E_q_zeta <- vector("list", length = N)#
  Cov_q_zeta <- vector("list", length = N)#
  for(i in 1:N) {#
#
    E_q_zeta[[i]] <- rnorm(L, 0, sigma_zeta)#
    Cov_q_zeta[[i]] <- diag(L)#
  }
sigma_zeta
CTC <- vector("list", length = N)#
  for(i in 1:N) {#
    CTC[[i]] <- vector("list", length = p)#
    for(j in 1:p) {#
      CTC[[i]][[j]] <- crossprod(C[[i]][[j]])#
    }#
  }
mu_inds <- vector("list", length = p)#
  psi_inds <- vector("list", length = p)#
  for(j in 1:p) {#
    mu_inds[[j]] <- 1:(K[j] + 2)#
    psi_inds[[j]] <- split((K[j] + 3):((K[j] + 2)*(L + 1)), rep(1:L, each = K[j] + 2))#
  }
mu_inds
psi_inds
E_q_recip_sigsq_eps <- rep(1, p)#
  E_q_recip_a_eps <- rep(1, p)#
  E_q_recip_sigsq_mu <- rep(1, p)#
  E_q_recip_a_mu <- rep(1, p)#
  E_q_recip_sigsq_psi <- matrix(1, nrow = p, ncol = L)#
  E_q_recip_a_psi <- matrix(1, nrow = p, ncol = L)#
  E_q_zeta <- vector("list", length = N)#
  Cov_q_zeta <- vector("list", length = N)#
  for(i in 1:N) {#
    E_q_zeta[[i]] <- rnorm(L, 0, sigma_zeta)#
    Cov_q_zeta[[i]] <- diag(L)#
  }
Cov_q_nu <- vector("list", length = p)#
    E_q_nu <- vector("list", length = p)#
    for(j in 1:p) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        Cov_sum <- Cov_sum + kronecker(E_q_zetazetaT_tilde, CTC[[i]][[j]])#
        mu_sum <- mu_sum + cprod(kronecker(t(E_q_zeta_tilde), C[[i]][[j]]), Y[[i]][[j]])#
      }#
      inv_fixed_var <- 1/sigsq_beta*diag(2)#
      E_q_Sigma_mu <- adiag(inv_fixed_var, E_q_recip_sigsq_mu[j]*diag(K[j]))#
      E_q_Sigma_psi <- vector("list", length = L)#
      for(l in 1:L) {#
        E_q_Sigma_psi[[l]] <- adiag(inv_fixed_var, E_q_recip_sigsq_psi[j, l]*diag(K[j]))#
      }#
      E_q_inv_Sigma_nu <- adiag(E_q_Sigma_mu, Reduce(adiag, E_q_Sigma_psi))#
      Cov_q_nu[[j]] <- solve(E_q_recip_sigsq_eps[j]*Cov_sum + E_q_inv_Sigma_nu)#
      E_q_nu[[j]] <- E_q_recip_sigsq_eps[j]*as.vector(Cov_q_nu[[j]] %*% mu_sum)#
    }
E_q_V <- vector("list", length = p)#
    E_q_V_psi <- vector("list", length = p)#
    for(j in 1:p) {#
      E_q_V_psi[[j]] <- matrix(E_q_nu[[j]][-mu_inds[[j]]], K[j] + 2, L)#
      E_q_V[[j]] <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    }
E_q_H_psi <- vector("list", length = N)#
    E_q_h_nu <- vector("list", length = N)#
    E_q_h_mu <- vector("list", length = N)#
    E_q_H_nu <- vector("list", length = N)#
    for(i in 1:N) {#
      E_q_H_psi[[i]] <- vector("list", length = p)#
      E_q_h_nu[[i]] <- vector("list", length = p)#
      E_q_h_mu[[i]] <- vector("list", length = p)#
      E_q_H_nu[[i]] <- vector("list", length = p)#
      for(j in 1:p) {#
        Cov_j <- Cov_q_nu[[j]]#
        E_j <- E_q_nu[[j]]#
        E_q_H_psi[[i]][[j]] <- matrix(NA, L, L)#
        E_q_h_nu[[i]][[j]] <- rep(NA, L)#
        for(l_1 in 1:L) {#
          inds_1 <- psi_inds[[j]][[l_1]]#
          for(l_2 in 1:L) {#
            inds_2 <- psi_inds[[j]][[l_2]]#
            tr_term <- tr(Cov_j[inds_2, inds_1] %*% CTC[[i]][[j]])#
            cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[inds_2])#
            E_q_H_psi[[i]][[j]][l_1, l_2] <- tr_term + cprod_term#
          }#
          tr_term <- tr(Cov_j[mu_inds[[j]], inds_1] %*% CTC[[i]][[j]])#
          cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
          E_q_h_nu[[i]][[j]][l_1] <- tr_term + cprod_term#
        }#
        tr_term <- tr(Cov_j[mu_inds[[j]], mu_inds[[j]]] %*% CTC[[i]][[j]])#
        cprod_term <- cprod(E_j[mu_inds[[j]]], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
        E_q_h_mu[[i]][[j]] <- tr_term + cprod_term#
        top_block <- cbind(E_q_h_mu[[i]][[j]], t(E_q_h_nu[[i]][[j]]))#
        bottom_block <- cbind(E_q_h_nu[[i]][[j]], E_q_H_psi[[i]][[j]])#
        E_q_H_nu[[i]][[j]] <- rbind(top_block, bottom_block)#
      }#
    }
Cov_q_zeta <- vector("list", length = N)#
    E_q_zeta <- vector("list", length = N)#
    for(i in 1:N) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(j in 1:p) {#
        Cov_sum <- Cov_sum + E_q_recip_sigsq_eps[j]*E_q_H_psi[[i]][[j]]#
        E_q_Psi_j <- C[[i]][[j]] %*% E_q_V_psi[[j]]#
        freq_scores <- cprod(E_q_Psi_j, Y[[i]][[j]]) - E_q_h_nu[[i]][[j]]#
        mu_sum <- mu_sum + E_q_recip_sigsq_eps[j]*freq_scores#
      }#
      Cov_q_zeta[[i]] <- solve(Cov_sum + 1/sigsq_zeta*diag(L))#
      E_q_zeta[[i]] <- as.vector(Cov_q_zeta[[i]] %*% mu_sum)#
    }
lambda_q_sigsq_eps <- rep(0, p)#
    E_q_recip_sigsq_eps <- rep(NA, p)#
    for(j in 1:p) {#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        term_1 <- cprod(Y[[i]][[j]])#
        term_2 <- -2*cprod(Y[[i]][[j]], C[[i]][[j]] %*% E_q_V[[j]] %*% E_q_zeta_tilde)#
        term_3 <- tr(E_q_zetazetaT_tilde %*% E_q_H_nu[[i]][[j]])#
        lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + term_1 + term_2 + term_3#
      }#
      lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + E_q_recip_a_eps[j]#
      E_q_recip_sigsq_eps[j] <- (sum(n[, j]) + 1)/lambda_q_sigsq_eps[j]#
    }
lambda_q_a_eps <- E_q_recip_sigsq_eps + 1/A^2
E_q_recip_a_eps <- 2/lambda_q_a_eps
lambda_q_sigsq_mu <- rep(NA, p)#
    for(j in 1:p) {#
      u_inds <- mu_inds[[j]][3:(K[j] + 2)]#
      tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
      cprod_term <- cprod(E_q_nu[[j]][u_inds])#
      lambda_q_sigsq_mu[j] <- tr_term + cprod_term + E_q_recip_a_mu[j]#
    }#
    E_q_recip_sigsq_mu <- (K[j] + 1)/lambda_q_sigsq_mu
lambda_q_a_mu <- E_q_recip_sigsq_mu + 1/A^2
E_q_recip_a_mu <- 2/lambda_q_a_mu
lambda_q_sigsq_psi <- matrix(NA, p, L)#
    for(l in 1:L) {#
      for(j in 1:p) {#
        u_inds <- psi_inds[[j]][[l]]#
        tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
        cprod_term <- cprod(E_q_nu[[j]][u_inds])#
        lambda_q_sigsq_psi[j, l] <- tr_term + cprod_term + E_q_recip_a_psi[j, l]#
      }#
    }#
    E_q_recip_sigsq_psi <- (K[j] + 1)/lambda_q_sigsq_psi
lambda_q_a_psi <- E_q_recip_sigsq_psi + 1/A^2
E_q_recip_a_psi <- 2/lambda_q_a_psi
for(iter in 1:n_mfvb) {#
#
    if (verbose) {#
      cat("Iteration", iter,  "of", n_mfvb, "\n")#
    }#
#
    # Update q(nu):#
    Cov_q_nu <- vector("list", length = p)#
    E_q_nu <- vector("list", length = p)#
    for(j in 1:p) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        Cov_sum <- Cov_sum + kronecker(E_q_zetazetaT_tilde, CTC[[i]][[j]])#
        mu_sum <- mu_sum + cprod(kronecker(t(E_q_zeta_tilde), C[[i]][[j]]), Y[[i]][[j]])#
      }#
      inv_fixed_var <- 1/sigsq_beta*diag(2)#
      E_q_Sigma_mu <- adiag(inv_fixed_var, E_q_recip_sigsq_mu[j]*diag(K[j]))#
      E_q_Sigma_psi <- vector("list", length = L)#
      for(l in 1:L) {#
        E_q_Sigma_psi[[l]] <- adiag(inv_fixed_var, E_q_recip_sigsq_psi[j, l]*diag(K[j]))#
      }#
      E_q_inv_Sigma_nu <- adiag(E_q_Sigma_mu, Reduce(adiag, E_q_Sigma_psi))#
      Cov_q_nu[[j]] <- solve(E_q_recip_sigsq_eps[j]*Cov_sum + E_q_inv_Sigma_nu)#
      E_q_nu[[j]] <- E_q_recip_sigsq_eps[j]*as.vector(Cov_q_nu[[j]] %*% mu_sum)#
    }#
    E_q_V <- vector("list", length = p)#
    E_q_V_psi <- vector("list", length = p)#
    for(j in 1:p) {#
      E_q_V_psi[[j]] <- matrix(E_q_nu[[j]][-mu_inds[[j]]], K[j] + 2, L)#
      E_q_V[[j]] <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    }#
    E_q_H_psi <- vector("list", length = N)#
    E_q_h_nu <- vector("list", length = N)#
    E_q_h_mu <- vector("list", length = N)#
    E_q_H_nu <- vector("list", length = N)#
    for(i in 1:N) {#
      E_q_H_psi[[i]] <- vector("list", length = p)#
      E_q_h_nu[[i]] <- vector("list", length = p)#
      E_q_h_mu[[i]] <- vector("list", length = p)#
      E_q_H_nu[[i]] <- vector("list", length = p)#
      for(j in 1:p) {#
        Cov_j <- Cov_q_nu[[j]]#
        E_j <- E_q_nu[[j]]#
        E_q_H_psi[[i]][[j]] <- matrix(NA, L, L)#
        E_q_h_nu[[i]][[j]] <- rep(NA, L)#
        for(l_1 in 1:L) {#
          inds_1 <- psi_inds[[j]][[l_1]]#
          for(l_2 in 1:L) {#
            inds_2 <- psi_inds[[j]][[l_2]]#
            tr_term <- tr(Cov_j[inds_2, inds_1] %*% CTC[[i]][[j]])#
            cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[inds_2])#
            E_q_H_psi[[i]][[j]][l_1, l_2] <- tr_term + cprod_term#
          }#
          tr_term <- tr(Cov_j[mu_inds[[j]], inds_1] %*% CTC[[i]][[j]])#
          cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
          E_q_h_nu[[i]][[j]][l_1] <- tr_term + cprod_term#
        }#
        tr_term <- tr(Cov_j[mu_inds[[j]], mu_inds[[j]]] %*% CTC[[i]][[j]])#
        cprod_term <- cprod(E_j[mu_inds[[j]]], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
        E_q_h_mu[[i]][[j]] <- tr_term + cprod_term#
        top_block <- cbind(E_q_h_mu[[i]][[j]], t(E_q_h_nu[[i]][[j]]))#
        bottom_block <- cbind(E_q_h_nu[[i]][[j]], E_q_H_psi[[i]][[j]])#
        E_q_H_nu[[i]][[j]] <- rbind(top_block, bottom_block)#
      }#
    }#
    # For i = 1, ..., N, update q(zeta[i]):#
    Cov_q_zeta <- vector("list", length = N)#
    E_q_zeta <- vector("list", length = N)#
    for(i in 1:N) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(j in 1:p) {#
        Cov_sum <- Cov_sum + E_q_recip_sigsq_eps[j]*E_q_H_psi[[i]][[j]]#
        E_q_Psi_j <- C[[i]][[j]] %*% E_q_V_psi[[j]]#
        freq_scores <- cprod(E_q_Psi_j, Y[[i]][[j]]) - E_q_h_nu[[i]][[j]]#
        mu_sum <- mu_sum + E_q_recip_sigsq_eps[j]*freq_scores#
      }#
      Cov_q_zeta[[i]] <- solve(Cov_sum + 1/sigsq_zeta*diag(L))#
      E_q_zeta[[i]] <- as.vector(Cov_q_zeta[[i]] %*% mu_sum)#
    }#
    # For j = 1, ..., p, update q(sigsq_eps[j]):#
    lambda_q_sigsq_eps <- rep(0, p)#
    E_q_recip_sigsq_eps <- rep(NA, p)#
    for(j in 1:p) {#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        term_1 <- cprod(Y[[i]][[j]])#
        term_2 <- -2*cprod(Y[[i]][[j]], C[[i]][[j]] %*% E_q_V[[j]] %*% E_q_zeta_tilde)#
        term_3 <- tr(E_q_zetazetaT_tilde %*% E_q_H_nu[[i]][[j]])#
        lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + term_1 + term_2 + term_3#
      }#
      lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + E_q_recip_a_eps[j]#
      E_q_recip_sigsq_eps[j] <- (sum(n[, j]) + 1)/lambda_q_sigsq_eps[j]#
    }#
    # For j = 1, ..., p, update q(a_eps[j]):#
    lambda_q_a_eps <- E_q_recip_sigsq_eps + 1/A^2#
    E_q_recip_a_eps <- 2/lambda_q_a_eps#
    # For j = 1, ..., p, update q(sigsq_mu[j]):#
    lambda_q_sigsq_mu <- rep(NA, p)#
    for(j in 1:p) {#
      u_inds <- mu_inds[[j]][3:(K[j] + 2)]#
      tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
      cprod_term <- cprod(E_q_nu[[j]][u_inds])#
      lambda_q_sigsq_mu[j] <- tr_term + cprod_term + E_q_recip_a_mu[j]#
    }#
    E_q_recip_sigsq_mu <- (K[j] + 1)/lambda_q_sigsq_mu#
    # Update q(a_mu):#
    lambda_q_a_mu <- E_q_recip_sigsq_mu + 1/A^2#
    E_q_recip_a_mu <- 2/lambda_q_a_mu#
    # For j = 1, ..., p and l = 1, ..., L, update q(sigsq_psi[j, l]):#
    lambda_q_sigsq_psi <- matrix(NA, p, L)#
    for(l in 1:L) {#
      for(j in 1:p) {#
        u_inds <- psi_inds[[j]][[l]]#
        tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
        cprod_term <- cprod(E_q_nu[[j]][u_inds])#
        lambda_q_sigsq_psi[j, l] <- tr_term + cprod_term + E_q_recip_a_psi[j, l]#
      }#
    }#
    E_q_recip_sigsq_psi <- (K[j] + 1)/lambda_q_sigsq_psi#
    # For j = 1, ..., p and l = 1, ..., L, update q(a_psi[j, l]):#
    lambda_q_a_psi <- E_q_recip_sigsq_psi + 1/A^2#
    E_q_recip_a_psi <- 2/lambda_q_a_psi#
  }
E_q_Zeta <- Reduce(rbind, E_q_zeta)#
  E_q_mu <- vector("list", length = p)#
  E_q_Psi <- vector("list", length = p)#
  for(j in 1:p) {#
    E_q_V <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    gbl_post <- C_g[[j]] %*% E_q_V#
    E_q_mu[[j]] <- gbl_post[, 1]#
    E_q_Psi[[j]] <- gbl_post[, 1:L + 1]#
  }#
  E_q_mu <- Reduce(c, E_q_mu)#
  E_q_Psi <- Reduce(rbind, E_q_Psi)#
  svd_Psi <- svd(E_q_Psi)#
  U_psi <- svd_Psi$u#
  D_psi <- diag(svd_Psi$d)#
  V_psi <- svd_Psi$v#
  zeta_rotn <- t(E_q_Zeta %*% V_psi %*% D_psi)#
  C_zeta <- cov(t(zeta_rotn))#
  eigen_C <- eigen(C_zeta)#
  Q <- eigen_C$vectors#
  Lambda <- diag(eigen_C$values + 1e-10)#
  Psi_tilde <- U_psi %*% Q %*% sqrt(Lambda)#
  Zeta_tilde <- crossprod(zeta_rotn, Q %*% solve(sqrt(Lambda)))#
  mu_hat <- split(E_q_mu, rep(1:p, each = n_g))
Psi_hat <- matrix(NA, p*n_g, L)#
  Zeta_hat <- matrix(NA, N, L)#
  norm_vec <- rep(NA, L)#
  for(l in 1:L) {#
    psi_l <- split(Psi_tilde[, l], rep(1:p, each = n_g))#
    norm_vec[l] <- sqrt(sum(sapply(psi_l, function(x) trapint(time_g, x^2))))#
    Psi_hat[, l] <- Psi_tilde[, l]/norm_vec[l]#
    Zeta_hat[, l] <- norm_vec[l]*Zeta_tilde[, l]#
    if(!is.null(Psi_g))#
      Psi_g_comb <- vector("list", length = p)#
      for(j in 1:p) {#
        Psi_g_comb[[j]] <- Psi_g[[j]][, l]#
      }#
      Psi_g_comb <- Reduce(c, Psi_g_comb)#
      inner_prod_sign <- sign(cprod(Psi_g_comb, Psi_hat[, l]))#
      if(inner_prod_sign == -1) {#
        Psi_hat[, l] <- -Psi_hat[, l]#
        Zeta_hat[, l] <- -Zeta_hat[, l]#
      }#
    }#
  }#
  Psi_hat <- lapply(split(Psi_hat, rep(1:p, each = n_g)), matrix, nrow = n_g, ncol = L)
Psi_hat <- matrix(NA, p*n_g, L)#
  Zeta_hat <- matrix(NA, N, L)#
  norm_vec <- rep(NA, L)#
  for(l in 1:L) {#
    psi_l <- split(Psi_tilde[, l], rep(1:p, each = n_g))#
    norm_vec[l] <- sqrt(sum(sapply(psi_l, function(x) trapint(time_g, x^2))))#
    Psi_hat[, l] <- Psi_tilde[, l]/norm_vec[l]#
    Zeta_hat[, l] <- norm_vec[l]*Zeta_tilde[, l]#
    if(!is.null(Psi_g)) {#
      Psi_g_comb <- vector("list", length = p)#
      for(j in 1:p) {#
        Psi_g_comb[[j]] <- Psi_g[[j]][, l]#
      }#
      Psi_g_comb <- Reduce(c, Psi_g_comb)#
      inner_prod_sign <- sign(cprod(Psi_g_comb, Psi_hat[, l]))#
      if(inner_prod_sign == -1) {#
        Psi_hat[, l] <- -Psi_hat[, l]#
        Zeta_hat[, l] <- -Zeta_hat[, l]#
      }#
    }#
  }#
  Psi_hat <- lapply(split(Psi_hat, rep(1:p, each = n_g)), matrix, nrow = n_g, ncol = L)
Cov_zeta_hat <- vector("list", length = N)#
  rotn_mat <- V_psi %*% D_psi %*% Q %*% solve(sqrt(Lambda)) %*% diag(norm_vec)#
  for(i in 1:N) {#
    Cov_zeta_hat[[i]] <- crossprod(rotn_mat, Cov_q_zeta[[i]] %*% rotn_mat)#
  }
zeta_summary <- list_zeta_ellipse <- vector("list", length=N)
for(i in 1:N) {#
#
    zeta_mean <- Zeta_hat[i,][1:2]#
#
    zeta_ellipse <- ellipse(#
      Cov_zeta_hat[[i]][1:2, 1:2],#
      centre=zeta_mean,#
      level=0.95#
    )#
#
    list_zeta_ellipse[[i]] <- zeta_ellipse#
#
    zeta_summary[[i]] <- list(zeta_mean, zeta_ellipse)#
    names(zeta_summary[[i]]) <- c("mean", "credible boundary")#
  }
gbl_hat <- vector("list", length = L + 1)#
  list_Psi_hat <- vector("list", length = L)#
  gbl_hat[[1]] <- mu_hat <- as.matrix(Reduce(cbind, mu_hat)) # now deals with the case p = 1#
  for(l in 1:L) {#
#
    gbl_hat[[l+1]] <- list_Psi_hat[[l]] <- matrix(NA, n_g, p)#
    for(j in 1:p) {#
#
      gbl_hat[[l+1]][, j] <- list_Psi_hat[[l]][,j] <- Psi_hat[[j]][, l]#
    }#
  }
Y_summary <- Y_hat <- Y_low <- Y_upp <- vector("list", length = N)#
  for(i in 1:N) {#
#
    Y_summary[[i]] <- Y_hat[[i]] <- Y_low[[i]] <- Y_upp[[i]] <- vector("list", length = p)#
    for(j in 1:p) {#
#
      Y_hat_ij <- mu_hat[,j] + Psi_hat[[j]] %*% Zeta_hat[i, ]#
      sd_vec_ij <- sqrt(diag(tcrossprod(Psi_hat[[j]] %*% Cov_zeta_hat[[i]], Psi_hat[[j]])))#
#
      Y_summary[[i]][[j]] <- matrix(NA, n_g, 3)#
#
      Y_summary[[i]][[j]][, 1] <- Y_hat_ij + qnorm(0.025)*sd_vec_ij#
      Y_summary[[i]][[j]][, 2] <- Y_hat_ij#
      Y_summary[[i]][[j]][, 3] <- Y_hat_ij + qnorm(0.975)*sd_vec_ij#
      Y_hat[[i]][[j]] <- Y_hat_ij#
      Y_low[[i]][[j]] <- Y_hat_ij + qnorm(0.025)*sd_vec_ij#
      Y_upp[[i]][[j]] <- Y_hat_ij + qnorm(0.975)*sd_vec_ij#
    }#
  }
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
source("fpca_algs.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
traceback()
get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
grid_obj <- get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
traceback()
time_obs
K
n_g
time_g
format_univ
source("utils.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
time_vec <- unlist(time_obs)#
#
  if (is.null(t_min)) {#
    t_min <- 1.01*min(time_vec) - 0.01*max(time_vec)#
  }#
#
  if (is.null(t_max)) {#
    t_max <- 1.01*max(time_vec) - 0.01*min(time_vec)#
  }#
#
  if (is.null(int_knots)) {#
    int_knots <- lapply(#
      K, function(x) quantile(unique(time_vec), seq(0, 1, length = x)[-c(1, x)])#
    )#
  }
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
traceback()
Z_g <- lapply(#
    int_knots,#
    function(x) ZOSull(time_g, range.x = c(0, 1), intKnots = x)#
  )
t_min
time_g
t_min
t_max
source("utils.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
source("utils.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)
names(mfvb_res)
mfvb_res
names(mfvb_res)
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
display_fit <- function(N_sample, time_obs, time_g, Y, Y_hat, Y_low, Y_upp, offset = 0.1)
source("plot_functions.R")
display_fit(N_sample, time_obs, time_g, Y, Y_hat, Y_low, Y_upp, offset = 0.1)
N_sample <- sort(N_sample)
Y_hat
offset <- 0.1
list_ylim <- c(min(unlist(Y[N_sample]),#
                                   unlist(Y_low[N_sample]))-offset,#
                        max(unlist(Y[N_sample]),#
                            unlist(Y_upp[N_sample]))+offset)
par(mfrow = c(length(N_sample), 1))#
  for (i in N_sample) {#
    if (i == N_sample[length(N_sample)]) {#
      par(mar = c(4,4.5,1,1))#
    } else if (i == N_sample[1]){#
      par(mar = c(1,4.5,4,1))#
    } else {#
      par(mar = c(2.5,4.5,2.5,1))#
    }#
#
    plot(time_obs[[i]], Y[[i]],#
         main = "",#
         xlab = ifelse(i == N_sample[length(N_sample)], "time", ""),#
         ylab = parse(text=paste0("Y[", i, "]")),#
         pch = 20, col = "grey55",#
         xlim = c(0, 1),#
         ylim = list_ylim)#
    # c(min(Y[[i]], Y_low[[i]]))-offset,#
    #          max(Y[[i]], Y_upp[[i]]))+offset))#
    if (!is.null(Y_hat)) {#
      lwd <- 1.2#
      lines(time_g, Y_hat[[i]], col="black", lwd = lwd)#
      lines(time_g, Y_low[[i]], col="black",lwd = lwd,lty = 2)#
      lines(time_g, Y_upp[[i]], col="black",lwd = lwd,lty = 2)#
    }#
#
  }
i <- N_sample[1]
par(mfrow = c(length(N_sample), 1))
N_sample[length(N_sample)]
N_sample
i == N_sample[1]
par(mar = c(1,4.5,4,1))
plot(time_obs[[i]], Y[[i]],#
         main = "",#
         xlab = ifelse(i == N_sample[length(N_sample)], "time", ""),#
         ylab = parse(text=paste0("Y[", i, "]")),#
         pch = 20, col = "grey55",#
         xlim = c(0, 1),#
         ylim = list_ylim)
time_obs[[i]]
N_sample
display_fit_list <- function(1:p, N_sample, time_obs, time_g, Y,#
                             Y_hat, Y_low, Y_upp,#
                             Y_hat_add = NULL, Y_low_add = NULL, Y_upp_add = NULL, offset = 0.1,#
                             col_data = "grey55", col = "black", col_add = "blue",#
                             lwd = 1.2, lwd_add = 1.2)
source("plot_functions.R")
display_fit_list(1:p, N_sample, time_obs, time_g, Y,#
                             Y_hat, Y_low, Y_upp,#
                             Y_hat_add = NULL, Y_low_add = NULL, Y_upp_add = NULL, offset = 0.1,#
                             col_data = "grey55", col = "black", col_add = "blue",#
                             lwd = 1.2, lwd_add = 1.2)
display_eigenfunctions(p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
source("plot_functions.R")
display_eigenfunctions(1:p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
plot_scores(N_sample, p, Zeta,#
                        Zeta_hat, zeta_ellipse,#
                        Zeta_hat_add = NULL, zeta_ellipse_add = NULL,#
                        vec_col = c("black", "blue"), data_col = "red", mfrow = NULL)
rm(list = ls())#
#
using_hr_comp <- readline("Are you using Helene's computer (T/F)? ")
if(using_hr_comp) {#
  CORE_DIR <- Sys.getenv("CORE_DIR")#
} else {#
  CORE_DIR <- paste0(Sys.getenv("HOME"), "/Desktop/repos")#
}#
#
main_dir <- file.path(CORE_DIR, "bayesFPCA/R/")#
setwd(main_dir)
######### R script: mfpca_vmp.R ###########
#
# For comparing MFPCA via VMP and MFVB. The modifications are:#
# 1.  inferring eigenfunctions#
# 2.  inferring scores and including orthogonalization#
# 3.  inferring residual posteriors#
# 4.  functionalising the likelihood fragment#
# 5.  functionalising the orthogonalization#
# 6.  functionalising the data generation#
# 7.  functionalising the raw data plots#
# 8.  computing convergence#
# 9.  functionalising the likelihood cross-entropy#
# 10. functionalising the vmp algorithm#
# 11. functionalising the plots of the comparison of fits#
# 11. functionalising the plots of the comparison of global curves#
#
# Created: 01 JUL 2022#
# Last changed: 03 MAR 2023#
#
# Load libraries:#
#
library(MASS)#
library(magic)#
library(lattice)#
library(pracma)#
library(ellipse)#
library(splines)#
#
# Required functions:#
#
source("fpca_algs.r")#
source("OSullivan_splines.R")#
source("plot_functions.R")#
source("set_hyper.R")#
source("simulation_functions.R")#
source("utils.R")
# Establish simulation variables:#
#
n_obs <- list(10:20, 50:70, 30:40, 100:120)#
n_int_knots <- c(5, 15, 9, 25)                # number of interior knots#
#
p <- 3                                        # number of responses#
N <- 100                                      # number of curves#
n <- Reduce(                                  # number of time observations#
	cbind, lapply(#
		n_obs[1:p], sample,#
		size = N, replace = TRUE#
	)#
)#
n_sample <- 4                                 # number of curves for the plots#
N_sample <- sort(sample(1:N, n_sample))       # specific curves for the plots#
K <- n_int_knots[1:p] + 2                # number of spline basis functions#
L <- 2                              # number of FPCA basis functions#
data_col <- "grey51"                # colour of the data in the plots#
#
n_mfvb <- 250                       # number of vmp iterations#
n_g <- 1000                         # length of the plotting grid#
mfvb_col <- "red"                  # colour of the vmp plots#
plot_lwd <- 2#
#
criterion  <- 1e-5                        # convergence criterion#
#
sigma_zeta_vec <- 2*1/(1:L)           # sd for first and second scores#
sigma_eps <- rep(1, p)      # sd of the residuals#
sigsq_eps <- sigma_eps^2#
#
delta <- 1e-3                       # convergence threshold#
#
# Set up plotting variables:#
#
plot_dim <- c(4, 1)                 # (ncol, nrow) for curve plots#
plot_gbl_dim <- c(3, 1)             # (ncol, nrow) for the mean and basis function plots#
#
n_g <- 1000                         # length of plotting grid#
#
plot_width <- 6#
plot_height <- 6#
#
print_pdf <- FALSE#
#
# Establish hyperparameters:#
#
sigsq_beta <- 1e10#
Sigma_beta <- sigsq_beta*diag(2)#
mu_beta <- rep(0, 2)#
A <- 1e5#
sigsq_zeta <- 1#
sigma_zeta <- sqrt(sigsq_zeta)#
Sigma_zeta <- sigsq_zeta*diag(L)#
#
# Set the mean function and the FPCA basis functions:#
#
mu <- function(time_obs, j) {#
	ans <- ((-1)^j)*3*sin(pi*j*time_obs) - 3/2#
	return(ans)#
}#
#
psi_1 <- function(time_obs, j) {#
	ans <- sqrt(2/p)*sin(2*pi*j*time_obs)#
	return(ans)#
}#
#
psi_2 <- function(time_obs, j) {#
	ans <- sqrt(2/p)*cos(2*pi*j*time_obs)#
	return(ans)#
}#
#
Psi_func <- function(time_obs, j, p) {#
	ans <- cbind(psi_1(time_obs, j), psi_2(time_obs, j))#
	return(ans)#
}
#####################################################
##
#  SIMULATE  THE  DATA#
##
#####################################################
#
# Set up the data:#
#
mfpca_data <- gauss_mfpca_data(N, p, n, K, L, n_g, sigma_eps, mu_func, Psi_func)#
#
time_obs <- mfpca_data$"time_obs"#
time_g <- mfpca_data$"time_g"#
int_knots <- mfpca_data$"int_knots"#
C <- mfpca_data$"C"#
C_g <- mfpca_data$"C_g"#
Zeta <- mfpca_data$"Zeta"#
mu_g <- mfpca_data$"mu_g"#
Psi_g <- mfpca_data$"Psi_g"#
Y <- mfpca_data$"Y"#
#
CTC <- vector("list", length = N)#
for(i in 1:N) {#
	CTC[[i]] <- vector("list", length = p)#
	for(j in 1:p) {#
		CTC[[i]][[j]] <- crossprod(C[[i]][[j]])#
	}#
}
# Set up the data:#
#
mfpca_data <- gauss_mfpca_data(N, p, n, K, L, n_g, sigma_eps, mu, Psi_func)#
#
time_obs <- mfpca_data$"time_obs"#
time_g <- mfpca_data$"time_g"#
int_knots <- mfpca_data$"int_knots"#
C <- mfpca_data$"C"#
C_g <- mfpca_data$"C_g"#
Zeta <- mfpca_data$"Zeta"#
mu_g <- mfpca_data$"mu_g"#
Psi_g <- mfpca_data$"Psi_g"#
Y <- mfpca_data$"Y"#
#
CTC <- vector("list", length = N)#
for(i in 1:N) {#
	CTC[[i]] <- vector("list", length = p)#
	for(j in 1:p) {#
		CTC[[i]][[j]] <- crossprod(C[[i]][[j]])#
	}#
}
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
is.null(Psi_g)
display_fit_list(1:p, N_sample, time_obs, time_g, Y,#
                             Y_hat, Y_low, Y_upp,#
                             Y_hat_add = NULL, Y_low_add = NULL, Y_upp_add = NULL, offset = 0.1,#
                             col_data = "grey55", col = "black", col_add = "blue",#
                             lwd = 1.2, lwd_add = 1.2)
display_eigenfunctions(1:p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
E_q_Zeta
CTC
sigma_zeta
mu_beta
Sigma_beta
A
n
d
N
p
grid_obj
d <- (K+2)*(L+1)
grid_obj <- get_grid_objects(time_obs, K, n_g = n_g, time_g = time_g,#
                               format_univ = FALSE)
C <- grid_obj$C#
  n_g <- grid_obj$n_g#
  time_g <- grid_obj$time_g#
  C_g <- grid_obj$C_g
CTC <- vector("list", length = N)#
  for(i in 1:N) {#
    CTC[[i]] <- vector("list", length = p)#
    for(j in 1:p) {#
      CTC[[i]][[j]] <- crossprod(C[[i]][[j]])#
    }#
  }
# Set fixed parameters:#
#
  mu_inds <- vector("list", length = p)#
  psi_inds <- vector("list", length = p)#
  for(j in 1:p) {#
    mu_inds[[j]] <- 1:(K[j] + 2)#
    psi_inds[[j]] <- split((K[j] + 3):((K[j] + 2)*(L + 1)), rep(1:L, each = K[j] + 2))#
  }
# Initialisation#
#
  E_q_recip_sigsq_eps <- rep(1, p)#
  E_q_recip_a_eps <- rep(1, p)#
  E_q_recip_sigsq_mu <- rep(1, p)#
  E_q_recip_a_mu <- rep(1, p)#
  E_q_recip_sigsq_psi <- matrix(1, nrow = p, ncol = L)#
  E_q_recip_a_psi <- matrix(1, nrow = p, ncol = L)#
  E_q_zeta <- vector("list", length = N)#
  Cov_q_zeta <- vector("list", length = N)#
  for(i in 1:N) {#
    E_q_zeta[[i]] <- rnorm(L, 0, sigma_zeta)#
    Cov_q_zeta[[i]] <- diag(L)#
  }
# Iterations:#
#
  for(iter in 1:n_mfvb) {#
#
    if (verbose) {#
      cat("Iteration", iter,  "of", n_mfvb, "\n")#
    }#
#
    # Update q(nu):#
    Cov_q_nu <- vector("list", length = p)#
    E_q_nu <- vector("list", length = p)#
    for(j in 1:p) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        Cov_sum <- Cov_sum + kronecker(E_q_zetazetaT_tilde, CTC[[i]][[j]])#
        mu_sum <- mu_sum + cprod(kronecker(t(E_q_zeta_tilde), C[[i]][[j]]), Y[[i]][[j]])#
      }#
      inv_fixed_var <- 1/sigsq_beta*diag(2)#
      E_q_Sigma_mu <- adiag(inv_fixed_var, E_q_recip_sigsq_mu[j]*diag(K[j]))#
      E_q_Sigma_psi <- vector("list", length = L)#
      for(l in 1:L) {#
        E_q_Sigma_psi[[l]] <- adiag(inv_fixed_var, E_q_recip_sigsq_psi[j, l]*diag(K[j]))#
      }#
      E_q_inv_Sigma_nu <- adiag(E_q_Sigma_mu, Reduce(adiag, E_q_Sigma_psi))#
      Cov_q_nu[[j]] <- solve(E_q_recip_sigsq_eps[j]*Cov_sum + E_q_inv_Sigma_nu)#
      E_q_nu[[j]] <- E_q_recip_sigsq_eps[j]*as.vector(Cov_q_nu[[j]] %*% mu_sum)#
    }#
    E_q_V <- vector("list", length = p)#
    E_q_V_psi <- vector("list", length = p)#
    for(j in 1:p) {#
      E_q_V_psi[[j]] <- matrix(E_q_nu[[j]][-mu_inds[[j]]], K[j] + 2, L)#
      E_q_V[[j]] <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    }#
    E_q_H_psi <- vector("list", length = N)#
    E_q_h_nu <- vector("list", length = N)#
    E_q_h_mu <- vector("list", length = N)#
    E_q_H_nu <- vector("list", length = N)#
    for(i in 1:N) {#
      E_q_H_psi[[i]] <- vector("list", length = p)#
      E_q_h_nu[[i]] <- vector("list", length = p)#
      E_q_h_mu[[i]] <- vector("list", length = p)#
      E_q_H_nu[[i]] <- vector("list", length = p)#
      for(j in 1:p) {#
        Cov_j <- Cov_q_nu[[j]]#
        E_j <- E_q_nu[[j]]#
        E_q_H_psi[[i]][[j]] <- matrix(NA, L, L)#
        E_q_h_nu[[i]][[j]] <- rep(NA, L)#
        for(l_1 in 1:L) {#
          inds_1 <- psi_inds[[j]][[l_1]]#
          for(l_2 in 1:L) {#
            inds_2 <- psi_inds[[j]][[l_2]]#
            tr_term <- tr(Cov_j[inds_2, inds_1] %*% CTC[[i]][[j]])#
            cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[inds_2])#
            E_q_H_psi[[i]][[j]][l_1, l_2] <- tr_term + cprod_term#
          }#
          tr_term <- tr(Cov_j[mu_inds[[j]], inds_1] %*% CTC[[i]][[j]])#
          cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
          E_q_h_nu[[i]][[j]][l_1] <- tr_term + cprod_term#
        }#
        tr_term <- tr(Cov_j[mu_inds[[j]], mu_inds[[j]]] %*% CTC[[i]][[j]])#
        cprod_term <- cprod(E_j[mu_inds[[j]]], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
        E_q_h_mu[[i]][[j]] <- tr_term + cprod_term#
        top_block <- cbind(E_q_h_mu[[i]][[j]], t(E_q_h_nu[[i]][[j]]))#
        bottom_block <- cbind(E_q_h_nu[[i]][[j]], E_q_H_psi[[i]][[j]])#
        E_q_H_nu[[i]][[j]] <- rbind(top_block, bottom_block)#
      }#
    }#
    # For i = 1, ..., N, update q(zeta[i]):#
    Cov_q_zeta <- vector("list", length = N)#
    E_q_zeta <- vector("list", length = N)#
    for(i in 1:N) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(j in 1:p) {#
        Cov_sum <- Cov_sum + E_q_recip_sigsq_eps[j]*E_q_H_psi[[i]][[j]]#
        E_q_Psi_j <- C[[i]][[j]] %*% E_q_V_psi[[j]]#
        freq_scores <- cprod(E_q_Psi_j, Y[[i]][[j]]) - E_q_h_nu[[i]][[j]]#
        mu_sum <- mu_sum + E_q_recip_sigsq_eps[j]*freq_scores#
      }#
      Cov_q_zeta[[i]] <- solve(Cov_sum + 1/sigsq_zeta*diag(L))#
      E_q_zeta[[i]] <- as.vector(Cov_q_zeta[[i]] %*% mu_sum)#
    }#
    # For j = 1, ..., p, update q(sigsq_eps[j]):#
    lambda_q_sigsq_eps <- rep(0, p)#
    E_q_recip_sigsq_eps <- rep(NA, p)#
    for(j in 1:p) {#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        term_1 <- cprod(Y[[i]][[j]])#
        term_2 <- -2*cprod(Y[[i]][[j]], C[[i]][[j]] %*% E_q_V[[j]] %*% E_q_zeta_tilde)#
        term_3 <- tr(E_q_zetazetaT_tilde %*% E_q_H_nu[[i]][[j]])#
        lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + term_1 + term_2 + term_3#
      }#
      lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + E_q_recip_a_eps[j]#
      E_q_recip_sigsq_eps[j] <- (sum(n[, j]) + 1)/lambda_q_sigsq_eps[j]#
    }#
    # For j = 1, ..., p, update q(a_eps[j]):#
    lambda_q_a_eps <- E_q_recip_sigsq_eps + 1/A^2#
    E_q_recip_a_eps <- 2/lambda_q_a_eps#
    # For j = 1, ..., p, update q(sigsq_mu[j]):#
    lambda_q_sigsq_mu <- rep(NA, p)#
    for(j in 1:p) {#
      u_inds <- mu_inds[[j]][3:(K[j] + 2)]#
      tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
      cprod_term <- cprod(E_q_nu[[j]][u_inds])#
      lambda_q_sigsq_mu[j] <- tr_term + cprod_term + E_q_recip_a_mu[j]#
    }#
    E_q_recip_sigsq_mu <- (K[j] + 1)/lambda_q_sigsq_mu#
    # Update q(a_mu):#
    lambda_q_a_mu <- E_q_recip_sigsq_mu + 1/A^2#
    E_q_recip_a_mu <- 2/lambda_q_a_mu#
    # For j = 1, ..., p and l = 1, ..., L, update q(sigsq_psi[j, l]):#
    lambda_q_sigsq_psi <- matrix(NA, p, L)#
    for(l in 1:L) {#
      for(j in 1:p) {#
        u_inds <- psi_inds[[j]][[l]]#
        tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
        cprod_term <- cprod(E_q_nu[[j]][u_inds])#
        lambda_q_sigsq_psi[j, l] <- tr_term + cprod_term + E_q_recip_a_psi[j, l]#
      }#
    }#
    E_q_recip_sigsq_psi <- (K[j] + 1)/lambda_q_sigsq_psi#
    # For j = 1, ..., p and l = 1, ..., L, update q(a_psi[j, l]):#
    lambda_q_a_psi <- E_q_recip_sigsq_psi + 1/A^2#
    E_q_recip_a_psi <- 2/lambda_q_a_psi#
  }
verbose <- TRUE
# Iterations:#
#
  for(iter in 1:n_mfvb) {#
#
    if (verbose) {#
      cat("Iteration", iter,  "of", n_mfvb, "\n")#
    }#
#
    # Update q(nu):#
    Cov_q_nu <- vector("list", length = p)#
    E_q_nu <- vector("list", length = p)#
    for(j in 1:p) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        Cov_sum <- Cov_sum + kronecker(E_q_zetazetaT_tilde, CTC[[i]][[j]])#
        mu_sum <- mu_sum + cprod(kronecker(t(E_q_zeta_tilde), C[[i]][[j]]), Y[[i]][[j]])#
      }#
      inv_fixed_var <- 1/sigsq_beta*diag(2)#
      E_q_Sigma_mu <- adiag(inv_fixed_var, E_q_recip_sigsq_mu[j]*diag(K[j]))#
      E_q_Sigma_psi <- vector("list", length = L)#
      for(l in 1:L) {#
        E_q_Sigma_psi[[l]] <- adiag(inv_fixed_var, E_q_recip_sigsq_psi[j, l]*diag(K[j]))#
      }#
      E_q_inv_Sigma_nu <- adiag(E_q_Sigma_mu, Reduce(adiag, E_q_Sigma_psi))#
      Cov_q_nu[[j]] <- solve(E_q_recip_sigsq_eps[j]*Cov_sum + E_q_inv_Sigma_nu)#
      E_q_nu[[j]] <- E_q_recip_sigsq_eps[j]*as.vector(Cov_q_nu[[j]] %*% mu_sum)#
    }#
    E_q_V <- vector("list", length = p)#
    E_q_V_psi <- vector("list", length = p)#
    for(j in 1:p) {#
      E_q_V_psi[[j]] <- matrix(E_q_nu[[j]][-mu_inds[[j]]], K[j] + 2, L)#
      E_q_V[[j]] <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    }#
    E_q_H_psi <- vector("list", length = N)#
    E_q_h_nu <- vector("list", length = N)#
    E_q_h_mu <- vector("list", length = N)#
    E_q_H_nu <- vector("list", length = N)#
    for(i in 1:N) {#
      E_q_H_psi[[i]] <- vector("list", length = p)#
      E_q_h_nu[[i]] <- vector("list", length = p)#
      E_q_h_mu[[i]] <- vector("list", length = p)#
      E_q_H_nu[[i]] <- vector("list", length = p)#
      for(j in 1:p) {#
        Cov_j <- Cov_q_nu[[j]]#
        E_j <- E_q_nu[[j]]#
        E_q_H_psi[[i]][[j]] <- matrix(NA, L, L)#
        E_q_h_nu[[i]][[j]] <- rep(NA, L)#
        for(l_1 in 1:L) {#
          inds_1 <- psi_inds[[j]][[l_1]]#
          for(l_2 in 1:L) {#
            inds_2 <- psi_inds[[j]][[l_2]]#
            tr_term <- tr(Cov_j[inds_2, inds_1] %*% CTC[[i]][[j]])#
            cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[inds_2])#
            E_q_H_psi[[i]][[j]][l_1, l_2] <- tr_term + cprod_term#
          }#
          tr_term <- tr(Cov_j[mu_inds[[j]], inds_1] %*% CTC[[i]][[j]])#
          cprod_term <- cprod(E_j[inds_1], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
          E_q_h_nu[[i]][[j]][l_1] <- tr_term + cprod_term#
        }#
        tr_term <- tr(Cov_j[mu_inds[[j]], mu_inds[[j]]] %*% CTC[[i]][[j]])#
        cprod_term <- cprod(E_j[mu_inds[[j]]], CTC[[i]][[j]] %*% E_j[mu_inds[[j]]])#
        E_q_h_mu[[i]][[j]] <- tr_term + cprod_term#
        top_block <- cbind(E_q_h_mu[[i]][[j]], t(E_q_h_nu[[i]][[j]]))#
        bottom_block <- cbind(E_q_h_nu[[i]][[j]], E_q_H_psi[[i]][[j]])#
        E_q_H_nu[[i]][[j]] <- rbind(top_block, bottom_block)#
      }#
    }#
    # For i = 1, ..., N, update q(zeta[i]):#
    Cov_q_zeta <- vector("list", length = N)#
    E_q_zeta <- vector("list", length = N)#
    for(i in 1:N) {#
      Cov_sum <- 0#
      mu_sum <- 0#
      for(j in 1:p) {#
        Cov_sum <- Cov_sum + E_q_recip_sigsq_eps[j]*E_q_H_psi[[i]][[j]]#
        E_q_Psi_j <- C[[i]][[j]] %*% E_q_V_psi[[j]]#
        freq_scores <- cprod(E_q_Psi_j, Y[[i]][[j]]) - E_q_h_nu[[i]][[j]]#
        mu_sum <- mu_sum + E_q_recip_sigsq_eps[j]*freq_scores#
      }#
      Cov_q_zeta[[i]] <- solve(Cov_sum + 1/sigsq_zeta*diag(L))#
      E_q_zeta[[i]] <- as.vector(Cov_q_zeta[[i]] %*% mu_sum)#
    }#
    # For j = 1, ..., p, update q(sigsq_eps[j]):#
    lambda_q_sigsq_eps <- rep(0, p)#
    E_q_recip_sigsq_eps <- rep(NA, p)#
    for(j in 1:p) {#
      for(i in 1:N) {#
        E_q_zeta_tilde <- c(1, E_q_zeta[[i]])#
        Cov_q_zeta_tilde <- adiag(0, Cov_q_zeta[[i]])#
        E_q_zetazetaT_tilde <- Cov_q_zeta_tilde + tcrossprod(E_q_zeta_tilde)#
        term_1 <- cprod(Y[[i]][[j]])#
        term_2 <- -2*cprod(Y[[i]][[j]], C[[i]][[j]] %*% E_q_V[[j]] %*% E_q_zeta_tilde)#
        term_3 <- tr(E_q_zetazetaT_tilde %*% E_q_H_nu[[i]][[j]])#
        lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + term_1 + term_2 + term_3#
      }#
      lambda_q_sigsq_eps[j] <- lambda_q_sigsq_eps[j] + E_q_recip_a_eps[j]#
      E_q_recip_sigsq_eps[j] <- (sum(n[, j]) + 1)/lambda_q_sigsq_eps[j]#
    }#
    # For j = 1, ..., p, update q(a_eps[j]):#
    lambda_q_a_eps <- E_q_recip_sigsq_eps + 1/A^2#
    E_q_recip_a_eps <- 2/lambda_q_a_eps#
    # For j = 1, ..., p, update q(sigsq_mu[j]):#
    lambda_q_sigsq_mu <- rep(NA, p)#
    for(j in 1:p) {#
      u_inds <- mu_inds[[j]][3:(K[j] + 2)]#
      tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
      cprod_term <- cprod(E_q_nu[[j]][u_inds])#
      lambda_q_sigsq_mu[j] <- tr_term + cprod_term + E_q_recip_a_mu[j]#
    }#
    E_q_recip_sigsq_mu <- (K[j] + 1)/lambda_q_sigsq_mu#
    # Update q(a_mu):#
    lambda_q_a_mu <- E_q_recip_sigsq_mu + 1/A^2#
    E_q_recip_a_mu <- 2/lambda_q_a_mu#
    # For j = 1, ..., p and l = 1, ..., L, update q(sigsq_psi[j, l]):#
    lambda_q_sigsq_psi <- matrix(NA, p, L)#
    for(l in 1:L) {#
      for(j in 1:p) {#
        u_inds <- psi_inds[[j]][[l]]#
        tr_term <- tr(Cov_q_nu[[j]][u_inds, u_inds])#
        cprod_term <- cprod(E_q_nu[[j]][u_inds])#
        lambda_q_sigsq_psi[j, l] <- tr_term + cprod_term + E_q_recip_a_psi[j, l]#
      }#
    }#
    E_q_recip_sigsq_psi <- (K[j] + 1)/lambda_q_sigsq_psi#
    # For j = 1, ..., p and l = 1, ..., L, update q(a_psi[j, l]):#
    lambda_q_a_psi <- E_q_recip_sigsq_psi + 1/A^2#
    E_q_recip_a_psi <- 2/lambda_q_a_psi#
  }
# Orthogonalisation:#
  E_q_Zeta <- Reduce(rbind, E_q_zeta)#
  E_q_mu <- vector("list", length = p)#
  E_q_Psi <- vector("list", length = p)#
  for(j in 1:p) {#
    E_q_V <- matrix(E_q_nu[[j]], K[j] + 2, L + 1)#
    gbl_post <- C_g[[j]] %*% E_q_V#
    E_q_mu[[j]] <- gbl_post[, 1]#
    E_q_Psi[[j]] <- gbl_post[, 1:L + 1]#
  }#
  E_q_mu <- Reduce(c, E_q_mu)#
  E_q_Psi <- Reduce(rbind, E_q_Psi)#
  svd_Psi <- svd(E_q_Psi)#
  U_psi <- svd_Psi$u#
  D_psi <- diag(svd_Psi$d)#
  V_psi <- svd_Psi$v#
  zeta_rotn <- t(E_q_Zeta %*% V_psi %*% D_psi)#
  C_zeta <- cov(t(zeta_rotn))#
  eigen_C <- eigen(C_zeta)#
  Q <- eigen_C$vectors#
  Lambda <- diag(eigen_C$values + 1e-10)#
  Psi_tilde <- U_psi %*% Q %*% sqrt(Lambda)#
  Zeta_tilde <- crossprod(zeta_rotn, Q %*% solve(sqrt(Lambda)))#
  mu_hat <- split(E_q_mu, rep(1:p, each = n_g))
Psi_hat <- matrix(NA, p*n_g, L)
Zeta_hat <- matrix(NA, N, L)
norm_vec <- rep(NA, L)
l <- 1
psi_l <- split(Psi_tilde[, l], rep(1:p, each = n_g))
psi_l
norm_vec[l] <- sqrt(sum(sapply(psi_l, function(x) trapint(time_g, x^2))))
norm_vec
Psi_hat[, l] <- Psi_tilde[, l]/norm_vec[l]
Zeta_hat[, l] <- norm_vec[l]*Zeta_tilde[, l]
!is.null(Psi_g)
Psi_g_comb <- vector("list", length = p)#
      for(j in 1:p) {#
        Psi_g_comb[[j]] <- Psi_g[[j]][, l]#
      }#
      Psi_g_comb <- Reduce(c, Psi_g_comb)
inner_prod_sign <- sign(cprod(Psi_g_comb, Psi_hat[, l]))
inner_prod_sign
Psi_hat[, l]
time_)g
time_g
plot(time_g, Psi_g_comb[1:n_g], type = "l")
lines(time_g, Psi_hat[1:n_g, l], col = "red")
plot(time_g, Psi_g_comb[(n_g + 1):(2*n_g)], type = "l")
lines(time_g, Psi_hat[(n_g + 1):(2*n_g), l], col = "red")
plot(time_g, Psi_g_comb[(2*n_g + 1):(3*n_g)], type = "l")
lines(time_g, Psi_hat[(2*n_g + 1):(3*n_g), l], col = "red")
inner_prod_sign
if(inner_prod_sign == -1) {#
        Psi_hat[, l] <- -Psi_hat[, l]#
        Zeta_hat[, l] <- -Zeta_hat[, l]#
      }
plot(time_g, Psi_g_comb[(2*n_g + 1):(3*n_g)], type = "l")
lines(time_g, Psi_hat[(2*n_g + 1):(3*n_g), l], col = "red")
plot(time_g, Psi_g_comb[1:n_g], type = "l")
lines(time_g, Psi_hat[1:n_g, l], col = "red")
plot(time_g, Psi_g_comb[(n_g + 1):(2*n_g)], type = "l")
lines(time_g, Psi_hat[(n_g + 1):(2*n_g), l], col = "red")
Psi_hat <- matrix(NA, p*n_g, L)#
  Zeta_hat <- matrix(NA, N, L)#
  norm_vec <- rep(NA, L)#
  for(l in 1:L) {#
    psi_l <- split(Psi_tilde[, l], rep(1:p, each = n_g))#
    norm_vec[l] <- sqrt(sum(sapply(psi_l, function(x) trapint(time_g, x^2))))#
    Psi_hat[, l] <- Psi_tilde[, l]/norm_vec[l]#
    Zeta_hat[, l] <- norm_vec[l]*Zeta_tilde[, l]#
    if(!is.null(Psi_g)) {#
      Psi_g_comb <- vector("list", length = p)#
      for(j in 1:p) {#
        Psi_g_comb[[j]] <- Psi_g[[j]][, l]#
      }#
      Psi_g_comb <- Reduce(c, Psi_g_comb)#
      inner_prod_sign <- sign(cprod(Psi_g_comb, Psi_hat[, l]))#
      if(inner_prod_sign == -1) {#
        Psi_hat[, l] <- -Psi_hat[, l]#
        Zeta_hat[, l] <- -Zeta_hat[, l]#
      }#
    }#
  }
Psi_hat
Psi_hat <- lapply(split(Psi_hat, rep(1:p, each = n_g)), matrix, nrow = n_g, ncol = L)
Cov_zeta_hat <- vector("list", length = N)#
  rotn_mat <- V_psi %*% D_psi %*% Q %*% solve(sqrt(Lambda)) %*% diag(norm_vec)#
  for(i in 1:N) {#
    Cov_zeta_hat[[i]] <- crossprod(rotn_mat, Cov_q_zeta[[i]] %*% rotn_mat)#
  }#
#
  # Store the results:#
#
  zeta_summary <- list_zeta_ellipse <- vector("list", length=N)#
#
  for(i in 1:N) {#
#
    zeta_mean <- Zeta_hat[i,][1:2]#
#
    zeta_ellipse <- ellipse(#
      Cov_zeta_hat[[i]][1:2, 1:2],#
      centre=zeta_mean,#
      level=0.95#
    )#
#
    list_zeta_ellipse[[i]] <- zeta_ellipse#
#
    zeta_summary[[i]] <- list(zeta_mean, zeta_ellipse)#
    names(zeta_summary[[i]]) <- c("mean", "credible boundary")#
  }
gbl_hat <- vector("list", length = L + 1)#
  list_Psi_hat <- vector("list", length = L)#
  gbl_hat[[1]] <- mu_hat <- as.matrix(Reduce(cbind, mu_hat)) # now deals with the case p = 1#
  for(l in 1:L) {#
#
    gbl_hat[[l+1]] <- list_Psi_hat[[l]] <- matrix(NA, n_g, p)#
    for(j in 1:p) {#
#
      gbl_hat[[l+1]][, j] <- list_Psi_hat[[l]][,j] <- Psi_hat[[j]][, l]#
    }#
  }
display_eigenfunctions(1:p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
source("fpca_algs.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = 500, n_g = 1000, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
display_eigenfunctions(1:p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
rm(list = ls())#
#
using_hr_comp <- readline("Are you using Helene's computer (T/F)? ")
if(using_hr_comp) {#
  CORE_DIR <- Sys.getenv("CORE_DIR")#
} else {#
  CORE_DIR <- paste0(Sys.getenv("HOME"), "/Desktop/repos")#
}#
#
main_dir <- file.path(CORE_DIR, "bayesFPCA/R/")#
setwd(main_dir)
getwd()
library(MASS)#
library(magic)#
library(lattice)#
library(pracma)#
library(ellipse)#
library(splines)#
#
# Required functions:#
#
source("fpca_algs.r")#
source("OSullivan_splines.R")#
source("plot_functions.R")#
source("set_hyper.R")#
source("simulation_functions.R")#
source("utils.R")#
#
# Establish simulation variables:#
#
n_obs <- list(10:20, 50:70, 30:40, 100:120)#
n_int_knots <- c(5, 15, 9, 25)                # number of interior knots#
#
p <- 3                                        # number of responses#
N <- 100                                      # number of curves#
n <- Reduce(                                  # number of time observations#
	cbind, lapply(#
		n_obs[1:p], sample,#
		size = N, replace = TRUE#
	)#
)#
n_sample <- 4                                 # number of curves for the plots#
N_sample <- sort(sample(1:N, n_sample))       # specific curves for the plots#
K <- n_int_knots[1:p] + 2                # number of spline basis functions#
L <- 2                              # number of FPCA basis functions#
data_col <- "grey51"                # colour of the data in the plots#
#
n_mfvb <- 250                       # number of vmp iterations#
n_g <- 1000                         # length of the plotting grid#
mfvb_col <- "red"                  # colour of the vmp plots#
plot_lwd <- 2#
#
criterion  <- 1e-5                        # convergence criterion#
#
sigma_zeta_vec <- 2*1/(1:L)           # sd for first and second scores#
sigma_eps <- rep(1, p)      # sd of the residuals#
sigsq_eps <- sigma_eps^2#
#
delta <- 1e-3                       # convergence threshold#
#
# Set up plotting variables:#
#
plot_dim <- c(4, 1)                 # (ncol, nrow) for curve plots#
plot_gbl_dim <- c(3, 1)             # (ncol, nrow) for the mean and basis function plots#
#
n_g <- 1000                         # length of plotting grid#
#
plot_width <- 6#
plot_height <- 6#
#
print_pdf <- FALSE#
#
# Establish hyperparameters:#
#
sigsq_beta <- 1e10#
Sigma_beta <- sigsq_beta*diag(2)#
mu_beta <- rep(0, 2)#
A <- 1e5#
sigsq_zeta <- 1#
sigma_zeta <- sqrt(sigsq_zeta)#
Sigma_zeta <- sigsq_zeta*diag(L)#
#
# Set the mean function and the FPCA basis functions:#
#
mu <- function(time_obs, j) {#
	ans <- ((-1)^j)*3*sin(pi*j*time_obs) - 3/2#
	return(ans)#
}#
#
psi_1 <- function(time_obs, j) {#
	ans <- sqrt(2/p)*sin(2*pi*j*time_obs)#
	return(ans)#
}#
#
psi_2 <- function(time_obs, j) {#
	ans <- sqrt(2/p)*cos(2*pi*j*time_obs)#
	return(ans)#
}#
#
Psi_func <- function(time_obs, j, p) {#
	ans <- cbind(psi_1(time_obs, j), psi_2(time_obs, j))#
	return(ans)#
}
#####################################################
##
#  SIMULATE  THE  DATA#
##
#####################################################
#
# Set up the data:#
#
mfpca_data <- gauss_mfpca_data(N, p, n, K, L, n_g, sigma_eps, mu, Psi_func)#
#
time_obs <- mfpca_data$"time_obs"#
time_g <- mfpca_data$"time_g"#
int_knots <- mfpca_data$"int_knots"#
C <- mfpca_data$"C"#
C_g <- mfpca_data$"C_g"#
Zeta <- mfpca_data$"Zeta"#
mu_g <- mfpca_data$"mu_g"#
Psi_g <- mfpca_data$"Psi_g"#
Y <- mfpca_data$"Y"#
#
CTC <- vector("list", length = N)#
for(i in 1:N) {#
	CTC[[i]] <- vector("list", length = p)#
	for(j in 1:p) {#
		CTC[[i]][[j]] <- crossprod(C[[i]][[j]])#
	}#
}
n_mfvb
n_g
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = n_mfvb, n_g = n_g, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
source("fpca_algs.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = n_mfvb, n_g = n_g, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
Psi_g
source("fpca_algs.R")
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = n_mfvb, n_g = n_g, time_g = NULL, Psi_g = NULL,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
mfvb_res <- run_mfvb_fpca(#
	time_obs, Y, K, L, list_hyper = NULL,#
	n_mfvb = n_mfvb, n_g = n_g, time_g = time_g, Psi_g = Psi_g,#
	verbose = TRUE, seed = NULL#
)#
#
time_g <- mfvb_res$"time_g"#
Y_summary <- mfvb_res$"Y_summary"#
Y_hat <- mfvb_res$"Y_hat"#
Y_low <- mfvb_res$"Y_low"#
Y_upp <- mfvb_res$"Y_upp"#
gbl_hat <- mfvb_res$"gbl_hat"#
mu_hat <- mfvb_res$"mu_hat"#
list_Psi_hat <- mfvb_res$"list_Psi_hat"#
Zeta_hat <- mfvb_res$"Zeta_hat"#
list_zeta_ellipse <- mfvb_res$"list_zeta_ellipse"
display_fit_list(1:p, N_sample, time_obs, time_g, Y,#
                             Y_hat, Y_low, Y_upp,#
                             Y_hat_add = NULL, Y_low_add = NULL, Y_upp_add = NULL, offset = 0.1,#
                             col_data = "grey55", col = "black", col_add = "blue",#
                             lwd = 1.2, lwd_add = 1.2)
display_eigenfunctions(1:p, L, time_g, mu_g, Psi_g,#
                                   mu_hat, list_Psi_hat,#
                                   mu_hat_add = NULL, list_Psi_hat_add = NULL,#
                                   mu_hat_ci = NULL, list_Psi_hat_ci = NULL,#
                                   lwd = 2, data_col = "red",#
                                   vec_col_add = NULL, vec_lwd = NULL)
length(list_zeta_ellipse)
list_zeta_ellipse[[1]]
zeta_summary <- vector("list", length = N)#
for(i in 1:N) {#
	zeta_summary[[i]] <- vector("list", length = 2)#
	zeta_summary[[i]][[1]] <- Zeta_hat[i, ]#
	zeta_summary[[i]][[2]] <- list_zeta_ellipse[[i]]#
}
plot_scores(N_sample, p, Zeta,#
                        Zeta_hat, zeta_ellipse,#
                        Zeta_hat_add = NULL, zeta_ellipse_add = NULL,#
                        vec_col = c("black", "blue"), data_col = "red", mfrow = NULL)
zeta_ellipse
plot_scores(N_sample, p, Zeta,#
                        Zeta_hat, list_zeta_ellipse,#
                        Zeta_hat_add = NULL, zeta_ellipse_add = NULL,#
                        vec_col = c("black", "blue"), data_col = "red", mfrow = NULL)
source("mfpca_mfvb.R")
